<!DOCTYPE html>
<html>
  <head>
    <style>
        @font-face {
            font-family: 'Hind';
            src: url('Hind-Regular.ttf') format('truetype');
            font-weight: 400;  /* Regular weight */
            font-style: normal;
        }
        @font-face {
            font-family: 'Hind';
            src: url('Hind-Medium.ttf') format('truetype');
            font-weight: 500;
            font-style: normal;
        }
        @font-face {
            font-family: 'Hind';
            src: url('Hind-SemiBold.ttf') format('truetype');
            font-weight: 600;
            font-style: normal;
        }
        @font-face {
            font-family: 'M PLUS 1p';
            src: url('MPLUS1p-Regular.ttf') format('truetype');
            font-weight: 400;
            font-style: normal;
        }
      * {
        font-family: "Hind", "M PLUS 1p", sans-serif;
        font-size: 16pt;
      }
      .heading {
        background-color: #00254c;
        color: white;
        font-size: 24pt;
        font-weight: 600;
        padding: 8px 16px;
        margin-bottom: .2em;
      }
      .sub {
        background-color: #00254c;
        color: white;
        border: none;
        border-radius: 4px;
        font-weight: 500;
        padding: 8px 16px;
        margin-top: .8em;
        cursor: pointer;
      }
      .sub:hover {
        background-color: #003366;
      }
      .result {
        margin-top: 20px;
        padding: 16px;
        border-radius: 4px;
        background-color: #f5f5f5;
        font-family: monospace;
        white-space: pre-wrap;
        word-wrap: break-word;
      }
      .error {
        background-color: #ffebee;
        color: #c62828;
      }
      .success {
        background-color: #e8f5e8;
        color: #2e7d32;
      }
      .loading {
        color: #666;
        font-style: italic;
      }
      .station-info {
        font-size: 14pt;
        color: #666;
        margin-top: 4px;
      }
      .route-display {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        line-height: 2.5;
        font-size: 20px;
      }
      .station-ruby {
        display: inline-flex;
        flex-direction: column;
        align-items: center;
        line-height: 1.2;
        margin: 0 2px;
        vertical-align: middle;
      }
      .ruby-text {
        font-size: 12px;
        color: #666;
        font-weight: normal;
        line-height: 1.2;
        white-space: nowrap;
      }
      .main-text {
        font-size: 24px;
        font-weight: bold;
      }
      .time-circle {
        display: inline-flex;
        flex-direction: column;
        align-items: center;
        margin: 0 4px;
        font-weight: bold;
      }
      .interchange {
        display: inline-flex;
        align-items: center;
        margin: 0 8px;
        font-size: 16px;
        color: #666;
      }
      .line-badge {
        display: inline-block;
        width: 16px;
        height: 16px;
        border-radius: 4px;
        margin: 0 4px;
      }
      .arrow {
        margin: 0 4px;
        color: #999;
      }
    </style>
  </head>
  <body hidden>
    <div class="heading">MTR Route</div>
    <form id="routeForm">
      <label for="src">From: </label><br>
      <input type="text" id="src" name="src" placeholder="TST / Tsim Sha Tsui / 尖沙咀" autocomplete="off"><br>
      <label for="dst">To: </label><br>
      <input type="text" id="dst" name="dst" placeholder="TST / Tsim Sha Tsui / 尖沙咀" autocomplete="off"><br>
      <input class="sub" type="submit" value="Calculate Route">
    </form>
    <div id="result" class="result"></div>
  </body>
  <script>
  document.querySelector('body').hidden = false;

  const LINE_COLORS = {
    'AEL': '#00888A', // Airport Express
    'TCL': '#F7943E', // Tung Chung Line
    'TML': '#923011', // Tuen Ma Line
    'TWL': '#ED1D24', // Tsuen Wan Line
    'ISL': '#007DC5', // Island Line
    'KTL': '#00AB4E', // Kwun Tong Line
    'EAL': '#53B7E8', // East Rail Line
    'SIL': '#BAC429', // South Island Line
    'TKL': '#7D499D', // Tseung Kwan O Line
    'DRL': '#F173AC', // Disneyland Resort Line
  };

  class PriorityQueue {
    constructor() {
      this.values = [];
    }

    enqueue(node, priority) {
      this.values.push({ node, priority });
      this.sort();
    }

    dequeue() {
      return this.values.shift();
    }

    sort() {
      this.values.sort((a, b) => a.priority - b.priority);
    }

    isEmpty() {
      return this.values.length === 0;
    }
  }

  class DijkstraAlgorithm {
    constructor(graph) {
      this.graph = graph;
    }

    findShortestPath(start, end) {
      const distances = {};
      const previous = {};
      const pq = new PriorityQueue();
      
      for (let node in this.graph) {
        distances[node] = node === start ? 0 : Infinity;
        previous[node] = null;
      }
      
      pq.enqueue(start, 0);

      while (!pq.isEmpty()) {
        const { node: current } = pq.dequeue();
        
        if (current === end) {
          break;
        }
        
        const neighbors = this.graph[current];
        
        if (neighbors) {
          for (let neighbor in neighbors) {
            const distance = distances[current] + neighbors[neighbor];
            
            if (distance < distances[neighbor]) {
              distances[neighbor] = distance;
              previous[neighbor] = current;
              pq.enqueue(neighbor, distance);
            }
          }
        }
      }

      return this.reconstructPath(previous, start, end, distances[end]);
    }

    reconstructPath(previous, start, end, totalTime) {
      const path = [];
      let current = end;
      
      while (current !== null) {
        path.unshift(current);
        current = previous[current];
      }
      
      if (path[0] !== start) {
        return {
          path: [],
          totalTime: Infinity,
          message: `No path found from ${start} to ${end}`
        };
      }

      return {
        path: path,
        totalTime: totalTime,
        message: `Shortest path from ${start} to ${end} takes ${totalTime} minutes`
      };
    }
  }

  class StationDatabase {
    constructor() {
      this.stations = new Map();
      this.nameIndex = new Map();
      this.lineInfo = new Map();
    }

    async loadFromCSV() {
      try {
        const response = await fetch('mtr_graph.csv');
        const csvText = await response.text();
        this.parseCSV(csvText);
        console.log(`Loaded ${this.stations.size} stations from CSV`);
        return true;
      } catch (error) {
        console.error('Error loading CSV:', error);
        return false;
      }
    }

    parseCSV(csvText) {
      const lines = csvText.trim().split('\n');
      for (let i = 1; i < lines.length; i++) {
        const line = lines[i].trim();
        if (!line) continue;
        
        const matches = line.match(/(".*?"|[^,]+)(?=\s*,|\s*$)/g);
        if (!matches || matches.length < 6) continue;
        
        const fields = matches.map(field => field.replace(/^"|"$/g, '').trim());
        
        const lineCode = fields[0];
        const stationCode = fields[2];
        const chineseName = fields[4];
        const englishName = fields[5];
        
        this.stations.set(stationCode, {
          code: stationCode,
          chinese: chineseName,
          english: englishName,
          lines: []
        });
        
        if (!this.lineInfo.has(stationCode)) {
          this.lineInfo.set(stationCode, new Set());
        }
        this.lineInfo.get(stationCode).add(lineCode);
        
        const station = this.stations.get(stationCode);
        station.lines = Array.from(this.lineInfo.get(stationCode));
        
        this.nameIndex.set(stationCode.toLowerCase(), stationCode);
        this.nameIndex.set(englishName.toLowerCase(), stationCode);
        this.nameIndex.set(chineseName.toLowerCase(), stationCode);
      }
    }

    findStation(input) {
      if (!input) return null;
      
      const normalizedInput = input.toLowerCase().trim();
      
      if (this.nameIndex.has(normalizedInput)) {
        const code = this.nameIndex.get(normalizedInput);
        return this.stations.get(code);
      }
      
      for (let [key, code] of this.nameIndex.entries()) {
        if (key.includes(normalizedInput) || normalizedInput.includes(key)) {
          return this.stations.get(code);
        }
      }
      
      return null;
    }

    getStationInfo(code) {
      return this.stations.get(code);
    }

    getStationLines(code) {
      return this.lineInfo.get(code) || new Set();
    }
  }

  class MTRRouteApp {
    constructor() {
      this.graph = null;
      this.dijkstra = null;
      this.stationDB = new StationDatabase();
      this.resultDiv = document.getElementById('result');
      this.form = document.getElementById('routeForm');
      
      this.form.addEventListener('submit', this.handleSubmit.bind(this));
    }

    async initialize() {
      this.showResult('Loading station data...', 'loading');
      
      const csvLoaded = await this.stationDB.loadFromCSV();
      if (!csvLoaded) {
        this.showResult('Warning: Station name database could not be loaded. Using station codes only.', 'error');
      }

      this.showResult('Loading MTR network...', 'loading');
      try {
        const response = await fetch('mtr_graph.json');
        this.graph = await response.json();
        this.dijkstra = new DijkstraAlgorithm(this.graph);
        this.showResult('Ready! Enter start and destination stations.', 'success');
      } catch (error) {
        this.showResult('Error loading MTR graph: ' + error.message, 'error');
      }
    }

    handleSubmit(event) {
      event.preventDefault();
      
      const srcInput = document.getElementById('src').value;
      const dstInput = document.getElementById('dst').value;
      
      if (!srcInput || !dstInput) {
        this.showResult('Please enter both start and destination stations.', 'error');
        return;
      }

      if (!this.graph || !this.dijkstra) {
        this.showResult('MTR network not loaded yet. Please wait.', 'error');
        return;
      }

      this.calculateRoute(srcInput, dstInput);
    }

    getTimeSymbol(minutes) {
      const timeCircles = ['①', '②', '③', '④', '⑤', '⑥', '⑦', '⑧', '⑨', '⑩', '⑪', '⑫', '⑬', '⑭', '⑮', '⑯', '⑰', '⑱', '⑲', '⑳'];
      return timeCircles[minutes - 1] || minutes;
    }

    formatRouteOutput(path, totalTime) {
      if (path.length < 2) return 'Invalid path';
      
      let output = '<div style="font-size: 24px; white-space: nowrap;">';
      
      // Add first station with ruby
      const firstStation = this.stationDB.getStationInfo(path[0]);
      output += this.formatStationWithRuby(path[0], firstStation);
      
      // Track current line for colors
      let currentLine = this.determineLine(path, 0);
      
      // Add each segment
      for (let i = 1; i < path.length; i++) {
        const time = this.graph[path[i-1]][path[i]];
        const nextLine = this.determineLine(path, i);
        
        // Add colored dash and time circle
        output += `<span style="color: ${LINE_COLORS[currentLine] || '#000'};"> ——${this.getTimeSymbol(time)}</span>`;
        
        // Add station
        const station = this.stationDB.getStationInfo(path[i]);
        output += this.formatStationWithRuby(path[i], station);
        
        // Update line if changed
        if (nextLine !== currentLine) {
          currentLine = nextLine;
        }
      }
      
      // Add total time
      output += ` | ${totalTime} min</div>`;
      
      return output;
    }

    determineLine(path, index) {
      const station = path[index];
      const lines = this.stationDB.getStationLines(station);
      
      if (index < path.length - 1) {
        const nextStation = path[index + 1];
        const nextLines = this.stationDB.getStationLines(nextStation);
        const commonLines = new Set([...lines].filter(x => nextLines.has(x)));
        if (commonLines.size > 0) {
          return Array.from(commonLines)[0];
        }
      }
      
      return Array.from(lines)[0] || 'Unknown';
    }

    formatStationWithRuby(code, station) {
      if (!station) {
        return `<span style="display: inline-flex; flex-direction: column; align-items: center; margin: 0 2px; vertical-align: middle;">
          <span style="font-size: 12px; color: #666;">&nbsp;</span>
          <span style="font-size: 24px; font-weight: bold;">${code}</span>
          <span style="font-size: 12px; color: #666;">&nbsp;</span>
        </span>`;
      }
      
      return `<span style="display: inline-flex; flex-direction: column; align-items: center; margin: 0 2px; vertical-align: middle;">
        <span style="font-size: 12px; color: #666; line-height: 1.2;">${station.english}</span>
        <span style="font-size: 24px; font-weight: bold;">${code}</span>
        <span style="font-size: 12px; color: #666; line-height: 1.2;">${station.chinese}</span>
      </span>`;
    }

    calculateRoute(srcInput, dstInput) {
      const srcStation = this.stationDB.findStation(srcInput);
      const dstStation = this.stationDB.findStation(dstInput);
      
      let srcCode = srcInput.trim().toUpperCase();
      let dstCode = dstInput.trim().toUpperCase();
      
      if (srcStation) srcCode = srcStation.code;
      if (dstStation) dstCode = dstStation.code;
      
      if (!this.graph[srcCode]) {
        this.showResult(`Station "${srcInput}" not found in network.`, 'error');
        return;
      }
      
      if (!this.graph[dstCode]) {
        this.showResult(`Station "${dstInput}" not found in network.`, 'error');
        return;
      }

      const result = this.dijkstra.findShortestPath(srcCode, dstCode);
      
      if (result.totalTime === Infinity) {
        this.showResult(result.message, 'error');
        return;
      }

      const formattedOutput = this.formatRouteOutput(result.path, result.totalTime);
      
      this.resultDiv.innerHTML = formattedOutput;
      this.resultDiv.className = 'result success';
    }

    showResult(message, type) {
      this.resultDiv.innerHTML = message;
      this.resultDiv.className = 'result ' + type;
    }
  }

  const app = new MTRRouteApp();
  app.initialize();
</script>
</html>
